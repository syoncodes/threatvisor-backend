import subprocess
import os
import requests
from pymongo import MongoClient
import re
from datetime import datetime
import json
import requests

# Connect to MongoDB
client = MongoClient("mongodb://syonb:syonsmart@ac-0w6souu-shard-00-00.jfanqj5.mongodb.net:27017,ac-0w6souu-shard-00-01.jfanqj5.mongodb.net:27017,ac-0w6souu-shard-00-02.jfanqj5.mongodb.net:27017/?replicaSet=atlas-yytbi1-shard-0&ssl=true&authSource=admin")
db = client['test']
collection = db['organizations']

def get_exploits_by_service_and_version(service, version):
    # Use searchsploit to get exploits based on service and version
    cmd = ['searchsploit', service, version]
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    # Split the result to get the path
    lines = result.stdout.splitlines()
    exploit_paths = [line.split('|')[-1].strip() for line in lines if ".txt" in line]
    
    exploits = []
    for path in exploit_paths:
        exploit_id = path.split('/')[-1].split('.')[0]
        exploit_link = f"https://www.exploit-db.com/exploits/{exploit_id}"
        
        # Get the full path of the exploit using searchsploit --path
        path_cmd = ['searchsploit', '--path', exploit_id]
        path_result = subprocess.run(path_cmd, capture_output=True, text=True)
        full_path = path_result.stdout.split("Path:")[1].split("\n")[0].strip()
        
        # Read the content of the exploit file directly
        with open(full_path, 'r') as file:
            exploit_content = file.read()
        
        # Examine the exploit using searchsploit +x to get additional details
        exploit_cmd = ['searchsploit', '+x', exploit_id]
        exploit_result = subprocess.run(exploit_cmd, capture_output=True, text=True)
        exploit_details = exploit_result.stdout.strip()

        exploits.append({
            "title": os.path.basename(path),
            "link": exploit_link,
            "content": exploit_content,
            "source": "ExploitDB"
        })

    # Use msfconsole to search for exploits based on service and version
    search_command = ["msfconsole", "-q", "-x", f"search {service} version:{version}; exit"]
    search_result = subprocess.run(search_command, capture_output=True, text=True).stdout
    
    # Extract the exploit name from the search results
    lines = search_result.split("\n")
    exploit_name = None
    for line in lines:
        if "exploit/" in line:
            exploit_name = line.split()[1]
            break

    # If an exploit is found, fetch its details
    if exploit_name:
        info_command = ["msfconsole", "-q", "-x", f"use {exploit_name}; info; exit"]
        info_result = subprocess.run(info_command, capture_output=True, text=True).stdout
        exploits.append({
            "title": exploit_name,
            "content": info_result,
            "source": "Metasploit"
        })

    return exploits

def get_cve_details_from_api(cve_id):
    try:
        api_url = f"https://cveawg.mitre.org/api/cve/{cve_id}"
        response = requests.get(api_url)
        response.raise_for_status()
        data = response.json()

        cve_details = {
            "title": data['cveMetadata']['cveId'],
            "link": f"https://www.cve.org/CVERecord?id={cve_id}",
            "content": data['containers']['cna']['descriptions'][0]['value'],
            "source": "MITRE"
        }

        return cve_details
    except Exception as e:
        print(f"Error fetching CVE details from API: {e}")
        return None

def get_exploitdb_details(cve_id):
    # Use searchsploit to get the path of the exploit
    cmd = ['searchsploit', '--cve', cve_id]
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    # Split the result to get the path
    lines = result.stdout.splitlines()
    exploit_paths = [line.split('|')[-1].strip() for line in lines if ".txt" in line]
    
    exploits = []
    for path in exploit_paths:
        exploit_id = path.split('/')[-1].split('.')[0]
        exploit_link = f"https://www.exploit-db.com/exploits/{exploit_id}"
        
        # Get the full path of the exploit using searchsploit --path
        path_cmd = ['searchsploit', '--path', exploit_id]
        path_result = subprocess.run(path_cmd, capture_output=True, text=True)
        full_path = path_result.stdout.split("Path:")[1].split("\n")[0].strip()
        
        # Read the content of the exploit file directly
        with open(full_path, 'r') as file:
            exploit_content = file.read()
        
        # Examine the exploit using searchsploit +x to get additional details
        exploit_cmd = ['searchsploit', '+x', exploit_id]
        exploit_result = subprocess.run(exploit_cmd, capture_output=True, text=True)
        exploit_details = exploit_result.stdout.strip()

        exploits.append({
            "title": cve_id,
            "link": exploit_link,
            "content": exploit_content,
            "source": "ExploitDB"
        })

    return exploits

def get_metasploit_details(cve_id):
    # Search for the CVE in Metasploit
    search_command = ["msfconsole", "-q", "-x", f"search cve:{cve_id}; exit"]
    search_result = subprocess.run(search_command, capture_output=True, text=True).stdout
    
    # Extract the exploit name from the search results
    lines = search_result.split("\n")
    exploit_name = None
    for line in lines:
        if "exploit/" in line:
            exploit_name = line.split()[1]
            break

    # If an exploit is found, fetch its details
    if exploit_name:
        info_command = ["msfconsole", "-q", "-x", f"use {exploit_name}; info; exit"]
        info_result = subprocess.run(info_command, capture_output=True, text=True).stdout
        return {
            "title": exploit_name,
            "content": info_result,
            "source": "Metasploit"
        }
    else:
        return None
def get_nvd_details(cve_id):
    try:
        url = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve_id}"  # Replace with your actual API endpoint
        response = requests.get(url)
        response.raise_for_status()  # Raise an exception for HTTP errors

        data = response.json()
        return data
    except requests.exceptions.HTTPError as http_err:
        print(f"HTTP error occurred: {http_err}")
    except json.JSONDecodeError as json_err:
        print(f"JSON decoding error occurred: {json_err}")
    except Exception as err:
        print(f"An error occurred: {err}")
    return None  # Return None in case of errors
    

def search_cve_in_document(cve_id):
    cve_api_details = get_cve_details_from_api(cve_id)
    exploitdb_exploits = get_exploitdb_details(cve_id)
    metasploit_exploit = get_metasploit_details(cve_id)
    nvd_details = get_nvd_details(cve_id)

    combined_results = []
    if cve_api_details:
        combined_results.append(cve_api_details)
    if exploitdb_exploits:
        combined_results.extend(exploitdb_exploits)
    if metasploit_exploit:
        combined_results.append(metasploit_exploit)
    if nvd_details:
        combined_results.append(nvd_details)

    return combined_results

def update_document_with_cve_results(user_id, endpoint_index, item_index, cve_id, cve_results):
    # Update the document with the results under the "exploits" key and a sub-key for the CVE
    collection.update_one(
        {"_id": user_id},
        {"$set": {f'endpoints.{endpoint_index}.items.{item_index}.exploits.{cve_id}': cve_results}}
    )

def extract_cves_from_document(document, endpoint_index, item_index):
    cves = set()
    results = document['endpoints'][endpoint_index]['items'][item_index].get('results', {})
    for risk_level, alerts in results.items():
        for alert_name, alert_list in alerts.items():
            for alert in alert_list:
                if isinstance(alert, dict):
                    other = alert.get("Other", "")
                elif isinstance(alert, str):
                    other = alert
                else:
                    continue  # Skip if the alert is neither a dictionary nor a string

                # Extract CVEs using regex
                cve_matches = re.findall(r'CVE-\d{4}-\d+', other)
                cves.update(cve_matches)

    return list(cves)


def update_document_with_service_exploits(user_id, endpoint_index, item_index, exploits):
    # Update the document with the results under the "exploits" key for the endpoint
    collection.update_one(
        {"_id": user_id},
        {"$set": {f'endpoints.{endpoint_index}.items.{item_index}.exploits': exploits}}
    )

def main():
    for document in collection.find({"endpoints.items.service": "Domain"}):
        user_id = document['_id']
        for endpoint_index, endpoint in enumerate(document['endpoints']):
            for item_index, item in enumerate(endpoint['items']):
                if item['service'] == "Domain" and 'url' in item:
                    domain = item['url']
                    scan_type = item.get('scan', 'passive')
                    last_scan_date = item.get('scanned', datetime.min)

                    # Extract CVEs from the scan results
                    cves = extract_cves_from_document(document, endpoint_index, item_index)
                    for cve_id in cves:
                        print(f"Searching for exploits related to CVE {cve_id} for domain {domain}...")
                        cve_results = search_cve_in_document(cve_id)
                        update_document_with_cve_results(user_id, endpoint_index, item_index, cve_id, cve_results)
                        print(f"Updated exploits for CVE {cve_id} for domain {domain}.")

import time

if __name__ == "__main__":
    while True:
        main()
        time.sleep(60)  # Sleep for 60 seconds before the next iteration
